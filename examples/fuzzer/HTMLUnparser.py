# Generated by Grammarinator 17.5r

from itertools import chain
from grammarinator.runtime import *


def html_space_transformer(node):

    for child in node.children:
        html_space_transformer(child)

    if isinstance(node, UnparserRule):
        new_children = []
        for child in node.children:
            new_children.append(child)
            if child.name == 'htmlTagName' and child.right_sibling and child.right_sibling.name == 'htmlAttribute' \
                    or child.name == 'htmlAttribute' \
                    or isinstance(child, UnlexerRule) and child.src and child.src.endswith(('<script', '<style', '<?xml')):
                new_children.append(UnlexerRule(src=' '))
        node.children = new_children

    return node



class HTMLUnparser(Grammarinator):

    def __init__(self, lexer):
        super(HTMLUnparser, self).__init__()
        self.lexer = lexer
        self.set_options()

    def set_options(self):
        self.options = dict(tokenVocab="HTMLLexer", dot="any_unicode_char")
    
    def endOfHtmlElement(self):
        pass
    def htmlDocument(self):
        current = self.create_node(UnparserRule(name='htmlDocument'))
        for _ in self.zero_or_more():
            weights = [1, 1]
            choice = self.choice(weights)
            if choice == 0:
                current += self.scriptlet()
            elif choice == 1:
                current += self.lexer.SEA_WS()

        for _ in self.zero_or_one():
            current += self.xml()

        for _ in self.zero_or_more():
            weights = [1, 1]
            choice = self.choice(weights)
            if choice == 0:
                current += self.scriptlet()
            elif choice == 1:
                current += self.lexer.SEA_WS()

        for _ in self.zero_or_one():
            current += self.dtd()

        for _ in self.zero_or_more():
            weights = [1, 1]
            choice = self.choice(weights)
            if choice == 0:
                current += self.scriptlet()
            elif choice == 1:
                current += self.lexer.SEA_WS()

        for _ in self.zero_or_more():
            current += self.htmlElements()

        return current

    def htmlElements(self):
        current = self.create_node(UnparserRule(name='htmlElements'))
        for _ in self.zero_or_more():
            current += self.htmlMisc()

        current += self.htmlElement()
        for _ in self.zero_or_more():
            current += self.htmlMisc()

        return current

    def htmlElement(self):
        local_ctx = dict()
        current = self.create_node(UnparserRule(name='htmlElement'))
        weights = [1, 1, 1, 1, 1, 1]
        choice = self.choice(weights)
        if choice == 0:
            current += self.lexer.TAG_OPEN()
            current += self.htmlTagName()
            local_ctx['open_tag'] = current.last_child
            for _ in self.zero_or_more():
                current += self.htmlAttribute()

            current += self.lexer.TAG_CLOSE()
            current += self.htmlContent()
            current += self.lexer.TAG_OPEN()
            current += self.lexer.TAG_SLASH()
            current += self.htmlTagName()
            current.last_child = local_ctx['open_tag'].deepcopy()
            current += self.lexer.TAG_CLOSE()
            self.endOfHtmlElement()
        elif choice == 1:
            current += self.lexer.TAG_OPEN()
            current += self.htmlTagName()
            local_ctx['open_tag'] = current.last_child
            for _ in self.zero_or_more():
                current += self.htmlAttribute()

            current += self.lexer.TAG_SLASH_CLOSE()
            self.endOfHtmlElement()
        elif choice == 2:
            current += self.lexer.TAG_OPEN()
            current += self.htmlTagName()
            local_ctx['open_tag'] = current.last_child
            for _ in self.zero_or_more():
                current += self.htmlAttribute()

            current += self.lexer.TAG_CLOSE()
            self.endOfHtmlElement()
        elif choice == 3:
            current += self.scriptlet()
        elif choice == 4:
            current += self.script()
        elif choice == 5:
            current += self.style()
        return current

    def htmlContent(self):
        current = self.create_node(UnparserRule(name='htmlContent'))
        for _ in self.zero_or_one():
            current += self.htmlChardata()

        for _ in self.zero_or_more():
            weights = [1, 1, 1]
            choice = self.choice(weights)
            if choice == 0:
                current += self.htmlElement()
            elif choice == 1:
                current += self.xhtmlCDATA()
            elif choice == 2:
                current += self.htmlComment()
            for _ in self.zero_or_one():
                current += self.htmlChardata()


        return current

    def htmlAttribute(self):
        local_ctx = dict()
        current = self.create_node(UnparserRule(name='htmlAttribute'))
        weights = [1, 1]
        choice = self.choice(weights)
        if choice == 0:
            current += self.htmlAttributeName()
            local_ctx['attr_name'] = current.last_child
            current += self.lexer.TAG_EQUALS()
            current += self.htmlAttributeValue()
        elif choice == 1:
            current += self.htmlAttributeName()
            local_ctx['attr_name'] = current.last_child
        return current

    def htmlAttributeName(self):
        current = self.create_node(UnparserRule(name='htmlAttributeName'))
        current += self.lexer.TAG_NAME()
        return current

    def htmlAttributeValue(self):
        current = self.create_node(UnparserRule(name='htmlAttributeValue'))
        current += self.lexer.ATTVALUE_VALUE()
        return current

    def htmlTagName(self):
        current = self.create_node(UnparserRule(name='htmlTagName'))
        current += self.lexer.TAG_NAME()
        return current

    def htmlChardata(self):
        current = self.create_node(UnparserRule(name='htmlChardata'))
        weights = [1, 1]
        choice = self.choice(weights)
        if choice == 0:
            current += self.lexer.HTML_TEXT()
        elif choice == 1:
            current += self.lexer.SEA_WS()
        return current

    def htmlMisc(self):
        current = self.create_node(UnparserRule(name='htmlMisc'))
        weights = [1, 1]
        choice = self.choice(weights)
        if choice == 0:
            current += self.htmlComment()
        elif choice == 1:
            current += self.lexer.SEA_WS()
        return current

    def htmlComment(self):
        current = self.create_node(UnparserRule(name='htmlComment'))
        weights = [1, 1]
        choice = self.choice(weights)
        if choice == 0:
            current += self.lexer.HTML_COMMENT()
        elif choice == 1:
            current += self.lexer.HTML_CONDITIONAL_COMMENT()
        return current

    def xhtmlCDATA(self):
        current = self.create_node(UnparserRule(name='xhtmlCDATA'))
        current += self.lexer.CDATA()
        return current

    def dtd(self):
        current = self.create_node(UnparserRule(name='dtd'))
        current += self.lexer.DTD()
        return current

    def xml(self):
        current = self.create_node(UnparserRule(name='xml'))
        current += self.lexer.XML_DECLARATION()
        return current

    def scriptlet(self):
        current = self.create_node(UnparserRule(name='scriptlet'))
        current += self.lexer.SCRIPTLET()
        return current

    def script(self):
        current = self.create_node(UnparserRule(name='script'))
        current += self.lexer.SCRIPT_OPEN()
        weights = [1, 1]
        choice = self.choice(weights)
        if choice == 0:
            current += self.lexer.SCRIPT_BODY()
        elif choice == 1:
            current += self.lexer.SCRIPT_SHORT_BODY()
        return current

    def style(self):
        current = self.create_node(UnparserRule(name='style'))
        current += self.lexer.STYLE_OPEN()
        weights = [1, 1]
        choice = self.choice(weights)
        if choice == 0:
            current += self.lexer.STYLE_BODY()
        elif choice == 1:
            current += self.lexer.STYLE_SHORT_BODY()
        return current

