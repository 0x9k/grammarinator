# Generated by Grammarinator 17.5r

from itertools import chain
from grammarinator.runtime import *


def html_space_transformer(node):

    for child in node.children:
        html_space_transformer(child)

    if isinstance(node, UnparserRule):
        new_children = []
        for child in node.children:
            new_children.append(child)
            if child.name == 'htmlTagName' and child.right_sibling and child.right_sibling.name == 'htmlAttribute' \
                    or child.name == 'htmlAttribute' \
                    or isinstance(child, UnlexerRule) and child.src and child.src.endswith(('<script', '<style', '<?xml')):
                new_children.append(UnlexerRule(src=' '))
        node.children = new_children

    return node



import HTMLUnlexer
class HTMLUnparser(Grammarinator):

    def __init__(self, lexer):
        super(HTMLUnparser, self).__init__()
        self.lexer = lexer
        self.set_options()

    def set_options(self):
        self.options = dict(tokenVocab="HTMLLexer", dot="any_unicode_char")

    
    def endOfHtmlElement(self):
        pass
    @depthcontrol
    def htmlDocument(self):
        current = self.create_node(UnparserRule(name='htmlDocument'))
        if self.lexer.max_depth >= 1:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [2, 1][i] > self.lexer.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    current += self.scriptlet()
                elif choice == 1:
                    current += self.lexer.SEA_WS()

        if self.lexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.xml()

        if self.lexer.max_depth >= 1:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [2, 1][i] > self.lexer.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    current += self.scriptlet()
                elif choice == 1:
                    current += self.lexer.SEA_WS()

        if self.lexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.dtd()

        if self.lexer.max_depth >= 1:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [2, 1][i] > self.lexer.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    current += self.scriptlet()
                elif choice == 1:
                    current += self.lexer.SEA_WS()

        if self.lexer.max_depth >= 4:
            for _ in self.zero_or_more():
                current += self.htmlElements()

        return current
    htmlDocument.min_depth = 0

    @depthcontrol
    def htmlElements(self):
        current = self.create_node(UnparserRule(name='htmlElements'))
        if self.lexer.max_depth >= 2:
            for _ in self.zero_or_more():
                current += self.htmlMisc()

        current += self.htmlElement()
        if self.lexer.max_depth >= 2:
            for _ in self.zero_or_more():
                current += self.htmlMisc()

        return current
    htmlElements.min_depth = 3

    @depthcontrol
    def htmlElement(self):
        local_ctx = dict()
        current = self.create_node(UnparserRule(name='htmlElement'))
        choice = self.choice([0 if [3, 3, 3, 2, 2, 2][i] > self.lexer.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        if choice == 0:
            current += self.lexer.TAG_OPEN()
            current += self.htmlTagName()
            local_ctx['open_tag'] = current.last_child
            if self.lexer.max_depth >= 4:
                for _ in self.zero_or_more():
                    current += self.htmlAttribute()

            current += self.lexer.TAG_CLOSE()
            current += self.htmlContent()
            current += self.lexer.TAG_OPEN()
            current += self.lexer.TAG_SLASH()
            current += self.htmlTagName()
            current.last_child = local_ctx['open_tag'].deepcopy()
            current += self.lexer.TAG_CLOSE()
            self.endOfHtmlElement()
        elif choice == 1:
            current += self.lexer.TAG_OPEN()
            current += self.htmlTagName()
            local_ctx['open_tag'] = current.last_child
            if self.lexer.max_depth >= 4:
                for _ in self.zero_or_more():
                    current += self.htmlAttribute()

            current += self.lexer.TAG_SLASH_CLOSE()
            self.endOfHtmlElement()
        elif choice == 2:
            current += self.lexer.TAG_OPEN()
            current += self.htmlTagName()
            local_ctx['open_tag'] = current.last_child
            if self.lexer.max_depth >= 4:
                for _ in self.zero_or_more():
                    current += self.htmlAttribute()

            current += self.lexer.TAG_CLOSE()
            self.endOfHtmlElement()
        elif choice == 3:
            current += self.scriptlet()
        elif choice == 4:
            current += self.script()
        elif choice == 5:
            current += self.style()
        return current
    htmlElement.min_depth = 2

    @depthcontrol
    def htmlContent(self):
        current = self.create_node(UnparserRule(name='htmlContent'))
        if self.lexer.max_depth >= 2:
            for _ in self.zero_or_one():
                current += self.htmlChardata()

        if self.lexer.max_depth >= 2:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [3, 2, 2][i] > self.lexer.max_depth else w for i, w in enumerate([1, 1, 1])])
                if choice == 0:
                    current += self.htmlElement()
                elif choice == 1:
                    current += self.xhtmlCDATA()
                elif choice == 2:
                    current += self.htmlComment()
                if self.lexer.max_depth >= 2:
                    for _ in self.zero_or_one():
                        current += self.htmlChardata()


        return current
    htmlContent.min_depth = 0

    @depthcontrol
    def htmlAttribute(self):
        local_ctx = dict()
        current = self.create_node(UnparserRule(name='htmlAttribute'))
        choice = self.choice([0 if [4, 3][i] > self.lexer.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            current += self.htmlAttributeName()
            local_ctx['attr_name'] = current.last_child
            current += self.lexer.TAG_EQUALS()
            current += self.htmlAttributeValue()
        elif choice == 1:
            current += self.htmlAttributeName()
            local_ctx['attr_name'] = current.last_child
        return current
    htmlAttribute.min_depth = 3

    @depthcontrol
    def htmlAttributeName(self):
        current = self.create_node(UnparserRule(name='htmlAttributeName'))
        current += self.lexer.TAG_NAME()
        return current
    htmlAttributeName.min_depth = 2

    @depthcontrol
    def htmlAttributeValue(self):
        current = self.create_node(UnparserRule(name='htmlAttributeValue'))
        current += self.lexer.ATTVALUE_VALUE()
        return current
    htmlAttributeValue.min_depth = 3

    @depthcontrol
    def htmlTagName(self):
        current = self.create_node(UnparserRule(name='htmlTagName'))
        current += self.lexer.TAG_NAME()
        return current
    htmlTagName.min_depth = 2

    @depthcontrol
    def htmlChardata(self):
        current = self.create_node(UnparserRule(name='htmlChardata'))
        choice = self.choice([0 if [1, 1][i] > self.lexer.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            current += self.lexer.HTML_TEXT()
        elif choice == 1:
            current += self.lexer.SEA_WS()
        return current
    htmlChardata.min_depth = 1

    @depthcontrol
    def htmlMisc(self):
        current = self.create_node(UnparserRule(name='htmlMisc'))
        choice = self.choice([0 if [2, 1][i] > self.lexer.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            current += self.htmlComment()
        elif choice == 1:
            current += self.lexer.SEA_WS()
        return current
    htmlMisc.min_depth = 1

    @depthcontrol
    def htmlComment(self):
        current = self.create_node(UnparserRule(name='htmlComment'))
        choice = self.choice([0 if [1, 1][i] > self.lexer.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            current += self.lexer.HTML_COMMENT()
        elif choice == 1:
            current += self.lexer.HTML_CONDITIONAL_COMMENT()
        return current
    htmlComment.min_depth = 1

    @depthcontrol
    def xhtmlCDATA(self):
        current = self.create_node(UnparserRule(name='xhtmlCDATA'))
        current += self.lexer.CDATA()
        return current
    xhtmlCDATA.min_depth = 1

    @depthcontrol
    def dtd(self):
        current = self.create_node(UnparserRule(name='dtd'))
        current += self.lexer.DTD()
        return current
    dtd.min_depth = 1

    @depthcontrol
    def xml(self):
        current = self.create_node(UnparserRule(name='xml'))
        current += self.lexer.XML_DECLARATION()
        return current
    xml.min_depth = 1

    @depthcontrol
    def scriptlet(self):
        current = self.create_node(UnparserRule(name='scriptlet'))
        current += self.lexer.SCRIPTLET()
        return current
    scriptlet.min_depth = 1

    @depthcontrol
    def script(self):
        current = self.create_node(UnparserRule(name='script'))
        current += self.lexer.SCRIPT_OPEN()
        choice = self.choice([0 if [1, 1][i] > self.lexer.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            current += self.lexer.SCRIPT_BODY()
        elif choice == 1:
            current += self.lexer.SCRIPT_SHORT_BODY()
        return current
    script.min_depth = 1

    @depthcontrol
    def style(self):
        current = self.create_node(UnparserRule(name='style'))
        current += self.lexer.STYLE_OPEN()
        choice = self.choice([0 if [1, 1][i] > self.lexer.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            current += self.lexer.STYLE_BODY()
        elif choice == 1:
            current += self.lexer.STYLE_SHORT_BODY()
        return current
    style.min_depth = 1

    default_rule = htmlDocument
